# Surviving the Event Loop

## Deep dive

- Instead of a single event queue (which only holds events), the event loop has at least 2 queues that in addition to events, hold other actions performed by the browser:
  1. Mactrotask queue
  2. Microtask queue

### Macro-tasks

- Creating the main DOM, parsing HTML, executing mainline (or global) JS code, changing the current URL, as well as various events such as: page loading, input, network and timer events.
- It is a discrete, self-contained unit of work.
- After a task is run, the browser can continue with other assignments such as re-rendering the UI of the page, or performing garbage collection.

### Micro-tasks

- Smaller tasks which update the application state and should be executed before the browser continues with other assignments such as re-rendering the UI.
- Examples include: promise callbacks and DOM mutation changes.
- Should be executed as soon as possible, in an async manner.
- Allow for us to execute certain actions _before_ the UI is re-rendered.

### Main Principles

1. Tasks are handled one at a time
2. A task runs to completion and can't be interrupted by another task

- In a single loop iteration, a single macro-task is performed, however, multiple micro-tasks can be performed.
- Once queues are done being checked, the event loop checks whether a UI render is required.

- Both task queues are placed outside of the event loop. The act of detecting and adding tasks is done separately from the event loop.
- Both types of tasks are executed one at a time.
- All microtasks should be executed before the next rendering.
- The browser usually tries to render the page 60 times per second.
- A single tasks and all microtasks generated by that task should ideally complete within 16 ms.

### Timers

- Timers are not defined within JavaScript itself but rather they are provided by the host environment (such as the browser on the client or Node.js on the server)

To be continued...
